
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>REMIXAVIER - Tools for recombining different mixes of a track</title><meta name="generator" content="MATLAB 7.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2013-07-01"><meta name="DC.source" content="demo_remixavier.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }

  </style></head><body><div class="content"><h1>REMIXAVIER - Tools for recombining different mixes of a track</h1><!--introduction--><p>2013-06-28 Dan Ellis <a href="mailto:dpwe@ee.columbia.edu">dpwe@ee.columbia.edu</a></p><p>The Remixavier ("remix savior") project is concerned with recovering the "difference" between different mixes of the same track.  For instance, given a full mix and an instrumental, we can try to recover the vocals, or given the full mix and an a cappella version, we can try to produce an instrumental version.  In the process, we can identify the precise temporal alignment between the two versions, which may be useful in its own right.</p><p>Assuming we have a full mix M and an instrumental version I, under ideal conditions we could recover the vocal line V as M - I.  However, there are very often timing offsets and small sampling rate differences (clock drift) that will defeat the simple approach.  We estimate these timimng differences with short-time cross correlation (in <a href="deskew.m">deskew.m</a>), and trim and resample to correct it to within a few parts per million (milliseconds of drift over the duration of a typical track).</p><p>But even with a perfect or near-perfect time alignment, there may be differences in gain, or more generally the channel frequency response, that will still make simple subtraction inadequate. Instead, we estimate the optimal equalization filter H to minimize the energy of M - H.I.  This is done within <a href="find_in_mix.m">find_in_mix.m</a>, which calls <a href="decomp_lin_win.m">decomp_lin_win.m</a> to break the pair of signals into short chunks (e.g. 8 second chunks every 4 second), estimate the best coupling impulse response of each chunk in <a href="decomp_lin.m">decomp_lin.m</a>, then overlap-add the canceled residuals to produce the desired difference.  This actually works by estimating a whitening filter for I so that the cross-correlation of the whitened versions of M and I is simply the coupling impulse response.</p><p>This approach to cancelation is inspired by the <a href="http://bass-db.gforge.inria.fr/bss_eval/">BSS_EVAL</a> procedure of Fevotte, Gribonval, and Vincent.  Essentially, we are finding the difference as the "artefacts residual" when M is considered an imperfect estimate of I.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Example 1: Significant time skew and channel difference</a></li><li><a href="#2">Channel estimation for example 1</a></li><li><a href="#3">Example 2: Recovering instrumental, in stereo</a></li><li><a href="#4">Example 3: Perfectly-aligned signals, and Weiner enhancement</a></li><li><a href="#5">Example 4: Imogen Heap Instrumental Version</a></li><li><a href="#6">Still to do</a></li></ul></div><h2>Example 1: Significant time skew and channel difference<a name="1"></a></h2><p>This example consists of an original instrumental track, digitized from a vinyl LP release, and a rap that uses the track as backing, taken directly from a CD.  Thus, the different signal paths mean that the timing is significantly different (clock drift of 0.1%), and the overall spectrum is very different too.</p><pre class="codeinput"><span class="comment">% Load in mix and acapella as mono files</span>
<span class="comment">% These tracks diverge at the end (different edits), so just work</span>
<span class="comment">% on the first minute</span>
sr = 44100;
[dmix,sr] = mp3read(<span class="string">'../Data/mc-paul-mix.mp3'</span>,[0 60*sr],1);
[dins,sr] = mp3read(<span class="string">'../Data/mc-paul-instr.mp3'</span>,[0 60*sr],1);

<span class="comment">% Attempt to trim and resample the full version to line up as well</span>
<span class="comment">% as possible with the acapella</span>
doplot = 1;
dmr = deskew(dmix, dins, sr, doplot);
axis([0.5 55.5 1 1.5])
<span class="comment">% It gets better when you repeat it</span>
dmr = deskew(dmr, dins, sr);
<span class="comment">% resampling can't handle ratios below 30 ppm, will just skip</span>
<span class="comment">% beyond that.</span>
</pre><pre class="codeoutput">Inital estimate of t_mix - t_ref = 1.258141 (mix starts before ref)
Calculating short-time cross-correlation...
Lin fit: t_mix = 0.998957 t_ref + 1.277
Resampling ratio: 1915/1917=0.998957
Inital estimate of t_mix - t_ref = 0.000000
Calculating short-time cross-correlation...
Lin fit: t_mix = 1.000001 t_ref + 0.001
</pre><img vspace="5" hspace="5" src="demo_remixavier_01.png" alt=""> <h2>Channel estimation for example 1<a name="2"></a></h2><pre class="codeinput"><span class="comment">% Do the short-time coupling filter estimation</span>
tic; [resid, targ, filt, SNR, del, filts] = <span class="keyword">...</span>
      find_in_mix(dmr,dins,sr,0.013,0.003); toc

<span class="comment">% Listen to the residual (vocals)</span>
<span class="comment">% (play the second 20 seconds)</span>
ix = 20*sr+[1:20*sr];
soundsc(resid(ix,:), sr);

<span class="comment">% Plot the time-local coupling filters (right channel)</span>
<span class="comment">% filter IR time base</span>
tt = [1:size(filts,1)]/sr;
<span class="comment">% times of individual short-time window (every 4 sec)</span>
tw = 4.0*[1:size(filts,2)];
<span class="comment">% plot</span>
imagesc(tt,tw,filts'); axis(<span class="string">'xy'</span>);
xlabel(<span class="string">'time / sec'</span>)
ylabel(<span class="string">'window time / sec'</span>)
title(<span class="string">'local coupling filter impulse responses (cap -&gt; mix)'</span>)
<span class="comment">% scale down impulse response extremes</span>
caxis([-2 2])
</pre><pre class="codeoutput">Delay = -0.000204 s
SNR = 0.26577 dB
Elapsed time is 10.154135 seconds.
</pre><img vspace="5" hspace="5" src="demo_remixavier_02.png" alt=""> <h2>Example 2: Recovering instrumental, in stereo<a name="3"></a></h2><p>The Duffy track has the vocals in stereo, we can cancel left and right separately to good effect</p><pre class="codeinput">[dmix,sr] = mp3read(<span class="string">'../Data/Duffy.WarwickAvenue.mp3'</span>);
[dcap,sr] = mp3read(<span class="string">'../Data/duffy_-_warwick_avenue_acapella.mp3'</span>);

<span class="comment">% Deskew will process stereo files.  Skew is estimated from an</span>
<span class="comment">% internally-generated mono mix</span>
dmr = deskew(dmix, dcap, sr);
dmr = deskew(dmr, dcap, sr);

clear <span class="string">resid</span> <span class="string">targ</span>

<span class="keyword">for</span> i = 1:size(dmr,2)
  tic; [resid(:,i), targ(:,i), filt, SNR, del, filts] = <span class="keyword">...</span>
                find_in_mix(dmr(:,i),dcap(:,i),sr,0.006,0.003); toc
<span class="keyword">end</span>

soundsc(resid(ix,:), sr);
</pre><pre class="codeoutput">Inital estimate of t_mix - t_ref = 10.304580 (mix starts before ref)
Calculating short-time cross-correlation...
Lin fit: t_mix = 1.005565 t_ref + 9.484
Resampling ratio: 14635/14554=1.005565
Inital estimate of t_mix - t_ref = 0.014966 (mix starts before ref)
Calculating short-time cross-correlation...
Lin fit: t_mix = 1.000324 t_ref + -0.024
Resampling ratio: 30891/30881=1.000324
Delay = -0.000499 s
SNR = -3.2852 dB
Elapsed time is 34.164715 seconds.
Delay = -0.000522 s
SNR = -3.4911 dB
Elapsed time is 34.761737 seconds.
</pre><h2>Example 3: Perfectly-aligned signals, and Weiner enhancement<a name="4"></a></h2><pre class="codeinput"><span class="comment">% Message In A Bottle is an ideal case - plain subtraction of mix</span>
<span class="comment">% and instrumental yeilds clean vocals.  But how does estimation do?</span>

<span class="comment">% Load tracks as mono</span>
sr = 44100;
dmix = mean(wavread(<span class="string">'../Data/message-in-a-bottle-mix.wav'</span>),2);
dins = mean(wavread(<span class="string">'../Data/message-in-a-bottle-ins.wav'</span>),2);

<span class="comment">% They shoyld be perfectly aligned already, but run deskew just in case</span>
dmr = deskew(dmix, dins, sr);

tic; [resid, targ, filt, SNR, del, filts] = <span class="keyword">...</span>
      find_in_mix(dmr,dins,sr,0.013,0.003); toc

soundsc(resid(ix,:), sr);

<span class="comment">% We can apply a "wiener filter" (scaling of spectrogram magnitude</span>
<span class="comment">% cells) to further reduce residual artifacts.  In particular, we</span>
<span class="comment">% can suppress cells where the energy in the estimated vocals is</span>
<span class="comment">% significantly lower than the energy in the instrumental line</span>
<span class="comment">% projected into the mix.  weinerenhace takes a threshold so that</span>
<span class="comment">% energy in the residual that is below -6 dB when compared to the</span>
<span class="comment">% accompaniment is suppressed</span>

reswf = weinerenhance(resid, targ, -6.0);
soundsc(reswf(ix,:), sr);

<span class="comment">% We can measure SNR by canceling against the true vocals, which</span>
<span class="comment">% are simply the difference of dmix and dins (for this perfect example)</span>
dvox = dmix - dins;
soundsc(dvox(ix,:), sr);  <span class="comment">% Yes, sounds clean</span>
[r2, t2, f2, S2, d2, fs2] = find_in_mix(resid,dvox,sr,0.010,0.003);
<span class="comment">%Delay = 0.000000 s</span>
<span class="comment">%SNR = 19.9197 dB  &lt;-- this is our estimate of SDR</span>
[r2, t2, f2, S2, d2, fs2] = find_in_mix(reswf,dvox,sr,0.010,0.003);
<span class="comment">%Delay = 0.000000 s</span>
<span class="comment">%SNR = 16.1096 dB</span>
<span class="comment">% Weiner filtering introduces more artifact energy than it removes</span>
<span class="comment">% interference.</span>
</pre><pre class="codeoutput">Inital estimate of t_mix - t_ref = 0.000000
Calculating short-time cross-correlation...
Lin fit: t_mix = 1.000000 t_ref + 0.000
Delay = 0.000000 s
SNR = 1.9983 dB
Elapsed time is 65.436237 seconds.
Delay = 0.000000 s
SNR = 19.9197 dB
Delay = 0.000000 s
SNR = 16.8997 dB
</pre><h2>Example 4: Imogen Heap Instrumental Version<a name="5"></a></h2><p>This album was released with two versions of every track - a full mix, and an instrumental version.  Since they are derived from the same digital masters, there is no clock drift, although they are not perfectly aligned in time.  However, because each short segment reflects the same timing alignment, we can average the estimated coupling filters to further stabilize the estimation. Because there are a few outlier frames (degenerate estimates from when the vocal track is near silent), we combine across filters with a median instead of a mean.</p><pre class="codeinput">[dmix,sr] = audioread(<span class="string">'../Data/10-Aha_.m4a'</span>);
[dins,sr] = audioread(<span class="string">'../Data/23-Aha_Instrumental_Version_.m4a'</span>);

<span class="comment">% Deskew once just to remove any gross timing offset</span>
dmr = deskew(dmix, dins, sr);

clear <span class="string">resid</span> <span class="string">targ</span> <span class="string">filts</span>

<span class="comment">% Align each channel, and store all the individual filters</span>
<span class="keyword">for</span> i = 1:size(dmr,2)
  tic; [resid(:,i), targ(:,i), filt, SNR, del, filts{i}] = <span class="keyword">...</span>
                find_in_mix(dmr(:,i),dins(:,i),sr,0.006,0.003); toc
<span class="keyword">end</span>

soundsc(resid(ix,:), sr);

<span class="comment">% but form a grand average filter for each side</span>
f1 = median(filts{1}');
f2 = median(filts{2}');

<span class="comment">% The estimated filter has a pre-echo, so trim that from the convolution</span>
[vv,xx] = max(abs(f1));
<span class="comment">% xx is the index of the peak on the impulse response</span>

<span class="comment">% .. then re-filter each side with this median average impulse response</span>
dinsf = [conv(f1,dins((xx+1):end,1)),conv(f2,dins((xx+1):end,2))];

<span class="comment">% .. which we can subtract out</span>
ll = min(length(dmr),length(dinsf));
dvx = dmr(1:ll,:) - dinsf(1:ll,:);
soundsc(dvx(ix,:),sr);

<span class="comment">% You can do OK with weiner enhancement even without cancelation</span>
fftlen = 2048;
[mixwf,M] = weinerenhance(dmr, dins, 12.0, 2.0, fftlen);
ff = [0:fftlen/2]*sr/fftlen;
tt = [1:size(M,2)]*fftlen/4/sr;
imagesc(tt,ff,M(:,:,1)); axis <span class="string">xy</span>  <span class="comment">% the spectrogram mask</span>
xlabel(<span class="string">'Time'</span>); ylabel(<span class="string">'Frequency'</span>);
axis([0 10 0 4000])
soundsc(mixwf(ix,:), sr);
<span class="comment">% but it sounds better based on the enhanced version</span>
[reswf,M] = weinerenhance(resid, targ, 12.0, 2.0);
soundsc(reswf(ix,:), sr);
</pre><pre class="codeoutput">Inital estimate of t_mix - t_ref = -0.025941 (ref starts before mix)
Calculating short-time cross-correlation...
Lin fit: t_mix = 1.000000 t_ref + -0.026
Delay = 0.000000 s
SNR = -2.0072 dB
Elapsed time is 23.394857 seconds.
Delay = 0.000000 s
SNR = -2.1378 dB
Elapsed time is 22.931311 seconds.
</pre><img vspace="5" hspace="5" src="demo_remixavier_03.png" alt=""> <h2>Still to do<a name="6"></a></h2><p>When the reference signal has very low energy, the coupling estimation goes crazy trying to boost it up to get rid of some of the energy.  We should put in some kind of regularization/threshold to stop this.</p><p>We don't expect the coupling filter to vary much along time, so we ought to be able to get an improvement by smoothing it along time (as in the median filtering on the Imogen Heap example). However, if there is any clock drift, we can't assume sample-level alignment of the individual impulse response estimates.  We could, however, estimate a single timing difference between each pair of impulse responses, then average them after backing that out.  For instance, we could fit a linear phase model to the phase responses of each individual coupling IR, then average their zero-phase versions, then reintroduce the individual phases (delays) to redistribute over each segment.</p><p class="footer"><br>
      Published with MATLAB&reg; 7.14<br></p></div><!--
##### SOURCE BEGIN #####
%% REMIXAVIER - Tools for recombining different mixes of a track
%
% 2013-06-28 Dan Ellis dpwe@ee.columbia.edu
%
% The Remixavier ("remix savior") project is concerned with recovering 
% the "difference" between different mixes of the same track.  For
% instance, given a full mix and an instrumental, we can try to
% recover the vocals, or given the full mix and an a cappella
% version, we can try to produce an instrumental version.  In the
% process, we can identify the precise temporal alignment between
% the two versions, which may be useful in its own right.
%
% Assuming we have a full mix M and an instrumental version I,
% under ideal conditions we could recover the vocal line V as M -
% I.  However, there are very often timing offsets and small sampling
% rate differences (clock drift) that will defeat the simple
% approach.  We estimate these timimng differences with short-time 
% cross correlation (in <deskew.m>), and trim and resample to
% correct it to within a few parts per million (milliseconds of
% drift over the duration of a typical track).
% 
% But even with a perfect or near-perfect time alignment, there may
% be differences in gain, or more generally the channel frequency
% response, that will still make simple subtraction inadequate.
% Instead, we estimate the optimal equalization filter H to
% minimize the energy of M - H.I.  This is done within 
% <find_in_mix.m>, which calls <decomp_lin_win.m> to break the 
% pair of signals into short chunks (e.g. 8 second chunks every 4
% second), estimate the best coupling impulse response of each
% chunk in <decomp_lin.m>, then overlap-add the canceled residuals 
% to produce the desired difference.  This actually works by
% estimating a whitening filter for I so that the cross-correlation of
% the whitened versions of M and I is simply the coupling impulse
% response.  
%
% This approach to cancelation is inspired by the 
% <http://bass-db.gforge.inria.fr/bss_eval/ BSS_EVAL>
% procedure of Fevotte, Gribonval, and Vincent.  Essentially, we
% are finding the difference as the "artefacts residual" when M is
% considered an imperfect estimate of I.  

%% Example 1: Significant time skew and channel difference
%
% This example consists of an original instrumental track,
% digitized from a vinyl LP release, and a rap that uses the track
% as backing, taken directly from a CD.  Thus, the different signal
% paths mean that the timing is significantly different (clock
% drift of 0.1%), and the overall spectrum is very different too. 

% Load in mix and acapella as mono files
% These tracks diverge at the end (different edits), so just work
% on the first minute 
sr = 44100;
[dmix,sr] = mp3read('../Data/mc-paul-mix.mp3',[0 60*sr],1);
[dins,sr] = mp3read('../Data/mc-paul-instr.mp3',[0 60*sr],1);

% Attempt to trim and resample the full version to line up as well
% as possible with the acapella
doplot = 1;
dmr = deskew(dmix, dins, sr, doplot);
axis([0.5 55.5 1 1.5])
% It gets better when you repeat it
dmr = deskew(dmr, dins, sr);
% resampling can't handle ratios below 30 ppm, will just skip
% beyond that.

%% Channel estimation for example 1

% Do the short-time coupling filter estimation
tic; [resid, targ, filt, SNR, del, filts] = ...
      find_in_mix(dmr,dins,sr,0.013,0.003); toc

% Listen to the residual (vocals)
% (play the second 20 seconds)
ix = 20*sr+[1:20*sr];
soundsc(resid(ix,:), sr);

% Plot the time-local coupling filters (right channel)
% filter IR time base
tt = [1:size(filts,1)]/sr;
% times of individual short-time window (every 4 sec)
tw = 4.0*[1:size(filts,2)];
% plot
imagesc(tt,tw,filts'); axis('xy');
xlabel('time / sec')
ylabel('window time / sec')
title('local coupling filter impulse responses (cap -> mix)')
% scale down impulse response extremes
caxis([-2 2])

%% Example 2: Recovering instrumental, in stereo
%
% The Duffy track has the vocals in stereo, we can cancel left and
% right separately to good effect

[dmix,sr] = mp3read('../Data/Duffy.WarwickAvenue.mp3');
[dcap,sr] = mp3read('../Data/duffy_-_warwick_avenue_acapella.mp3');

% Deskew will process stereo files.  Skew is estimated from an
% internally-generated mono mix
dmr = deskew(dmix, dcap, sr);
dmr = deskew(dmr, dcap, sr);

clear resid targ

for i = 1:size(dmr,2)
  tic; [resid(:,i), targ(:,i), filt, SNR, del, filts] = ...
                find_in_mix(dmr(:,i),dcap(:,i),sr,0.006,0.003); toc
end
  
soundsc(resid(ix,:), sr);


%% Example 3: Perfectly-aligned signals, and Weiner enhancement

% Message In A Bottle is an ideal case - plain subtraction of mix
% and instrumental yeilds clean vocals.  But how does estimation do?

% Load tracks as mono
sr = 44100;
dmix = mean(wavread('../Data/message-in-a-bottle-mix.wav'),2);
dins = mean(wavread('../Data/message-in-a-bottle-ins.wav'),2);

% They shoyld be perfectly aligned already, but run deskew just in case
dmr = deskew(dmix, dins, sr);

tic; [resid, targ, filt, SNR, del, filts] = ...
      find_in_mix(dmr,dins,sr,0.013,0.003); toc

soundsc(resid(ix,:), sr);

% We can apply a "wiener filter" (scaling of spectrogram magnitude
% cells) to further reduce residual artifacts.  In particular, we
% can suppress cells where the energy in the estimated vocals is
% significantly lower than the energy in the instrumental line
% projected into the mix.  weinerenhace takes a threshold so that
% energy in the residual that is below -6 dB when compared to the 
% accompaniment is suppressed

reswf = weinerenhance(resid, targ, -6.0);
soundsc(reswf(ix,:), sr);

% We can measure SNR by canceling against the true vocals, which
% are simply the difference of dmix and dins (for this perfect example)
dvox = dmix - dins;
soundsc(dvox(ix,:), sr);  % Yes, sounds clean
[r2, t2, f2, S2, d2, fs2] = find_in_mix(resid,dvox,sr,0.010,0.003); 
%Delay = 0.000000 s
%SNR = 19.9197 dB  <REPLACE_WITH_DASH_DASH this is our estimate of SDR
[r2, t2, f2, S2, d2, fs2] = find_in_mix(reswf,dvox,sr,0.010,0.003);
%Delay = 0.000000 s
%SNR = 16.1096 dB
% Weiner filtering introduces more artifact energy than it removes
% interference.

%% Example 4: Imogen Heap Instrumental Version
%
% This album was released with two versions of every track - a full
% mix, and an instrumental version.  Since they are derived from
% the same digital masters, there is no clock drift, although they
% are not perfectly aligned in time.  However, because each short
% segment reflects the same timing alignment, we can average the
% estimated coupling filters to further stabilize the estimation.
% Because there are a few outlier frames (degenerate estimates from
% when the vocal track is near silent), we combine across filters
% with a median instead of a mean.

[dmix,sr] = audioread('../Data/10-Aha_.m4a');
[dins,sr] = audioread('../Data/23-Aha_Instrumental_Version_.m4a');

% Deskew once just to remove any gross timing offset
dmr = deskew(dmix, dins, sr);

clear resid targ filts

% Align each channel, and store all the individual filters
for i = 1:size(dmr,2)
  tic; [resid(:,i), targ(:,i), filt, SNR, del, filts{i}] = ...
                find_in_mix(dmr(:,i),dins(:,i),sr,0.006,0.003); toc
end

soundsc(resid(ix,:), sr);

% but form a grand average filter for each side
f1 = median(filts{1}');
f2 = median(filts{2}');

% The estimated filter has a pre-echo, so trim that from the convolution
[vv,xx] = max(abs(f1));
% xx is the index of the peak on the impulse response

% .. then re-filter each side with this median average impulse response
dinsf = [conv(f1,dins((xx+1):end,1)),conv(f2,dins((xx+1):end,2))];

% .. which we can subtract out
ll = min(length(dmr),length(dinsf));
dvx = dmr(1:ll,:) - dinsf(1:ll,:);
soundsc(dvx(ix,:),sr);

% You can do OK with weiner enhancement even without cancelation
fftlen = 2048;
[mixwf,M] = weinerenhance(dmr, dins, 12.0, 2.0, fftlen);
ff = [0:fftlen/2]*sr/fftlen;
tt = [1:size(M,2)]*fftlen/4/sr;
imagesc(tt,ff,M(:,:,1)); axis xy  % the spectrogram mask
xlabel('Time'); ylabel('Frequency');
axis([0 10 0 4000])
soundsc(mixwf(ix,:), sr);
% but it sounds better based on the enhanced version
[reswf,M] = weinerenhance(resid, targ, 12.0, 2.0);
soundsc(reswf(ix,:), sr);

%% Still to do
%
% When the reference signal has very low energy, the coupling
% estimation goes crazy trying to boost it up to get rid of some of
% the energy.  We should put in some kind of
% regularization/threshold to stop this.
%
% We don't expect the coupling filter to vary much along time, so
% we ought to be able to get an improvement by smoothing it along
% time (as in the median filtering on the Imogen Heap example).
% However, if there is any clock drift, we can't assume
% sample-level alignment of the individual impulse response
% estimates.  We could, however, estimate a single timing
% difference between each pair of impulse responses, then average
% them after backing that out.  For instance, we could fit a linear
% phase model to the phase responses of each individual coupling
% IR, then average their zero-phase versions, then reintroduce the
% individual phases (delays) to redistribute over each segment.

##### SOURCE END #####
--></body></html>